@page "/"

@using System.IO;
@using System.Text;
@using System.Threading
@using SIL.Extensions
@using SIL.Machine.Annotations
@using SIL.Machine.FeatureModel
@using SIL.Machine.SequenceAlignment

@inject ProjectService _projectService
@inject DomService _domService

<header id="titlebar" class="@(_isMaximized ? "maximized" : "")">
    <div class="titlebar-buttons">
        <div>
            <MatIconButton Icon="menu" OnClick="@HandleOpenMenuAsync"></MatIconButton>
            <div @ref="_menuAnchor"></div>
        </div>

        <MatMenu @ref="_menu">
            <MatList Class="mdc-list--dense">
                <MatListItem OnClick="@HandleOpenProjectAsync">Open...</MatListItem>
                <MatDivider></MatDivider>
                <MatListItem OnClick="@HandleClose">Exit</MatListItem>
            </MatList>
        </MatMenu>
    </div>
    <div class="titlebar-drag-region">Cog Explorer @ProjectName</div>
    <div id="window-controls">
        <div class="button" id="min-button" @onclick="HandleMinimize">
            <span>&#xE921;</span>
        </div>
        <div class="button" id="max-button" @onclick="HandleMaximize">
            <span>&#xE922;</span>
        </div>
        <div class="button" id="restore-button" @onclick="HandleUnmaximize">
            <span>&#xE923;</span>
        </div>
        <div class="button" id="close-button" @onclick="HandleClose">
            <span>&#xE8BB;</span>
        </div>
    </div>
</header>
<div class="main-content">
    @if (!_projectService.IsLoaded)
    {
        <div class="mat-subtitle1">No project loaded.</div>
    }
    else
    {
        <div class="main-controls">
            <MatTextField @ref="_syllablePatternField"
                          Label="Syllable pattern"
                          OnInput="@HandleSyllablePatternInputAsync">
            </MatTextField>
            <div class="playback-rate-container">
                <div class="mat-caption playback-rate-label">Playback rate</div>
                <div class="playback-rate-slider">
                    <div class="mat-caption">0.5</div>
                    <MatSlider @bind-Value="@PlaybackRate"
                               ValueMin="0.5m"
                               ValueMax="1.0m"
                               Step="0.1m">
                    </MatSlider>
                    <div class="mat-caption">1.0</div>
                </div>
            </div>
        </div>
        <div class="data-grid-container">
            <DataGrid Columns="@_columns" Items="@_rows" PlaybackRate="@_playbackRate"></DataGrid>
        </div>
    }
</div>

@code {
    private ElementReference _menuAnchor;
    private MatMenu _menu;
    private MatTextField _syllablePatternField;
    private string _syllablePattern;
    private List<DataGridColumn> _columns = new List<DataGridColumn>();
    private List<PhraseRow> _rows = new List<PhraseRow>();
    private bool _isMaximized = false;
    private CancellationTokenSource _cts;
    private decimal _playbackRate = 1;

    private string SyllablePattern
    {
        get => _syllablePattern;
        set
        {
            if (_syllablePattern != value)
            {
                _syllablePattern = value;
                StateHasChanged();
                BuildDataGrid(_projectService.Project.Varieties.First());
            }
        }
    }

    private decimal PlaybackRate
    {
        get => _playbackRate;
        set
        {
            if (_playbackRate != value)
            {
                _playbackRate = value;
                StateHasChanged();
            }
        }
    }

    private string ProjectName => _projectService.IsLoaded ? $"- {_projectService.ProjectName}" : "";

    protected override async Task OnInitializedAsync()
    {
        BrowserWindow mainWindow = Electron.WindowManager.BrowserWindows.First();
        mainWindow.OnMaximize += async () =>
        {
            await InvokeAsync(() =>
            {
                _isMaximized = true;
                StateHasChanged();
            });
        };
        mainWindow.OnUnmaximize += async () =>
        {
            await InvokeAsync(() =>
            {
                _isMaximized = false;
                StateHasChanged();
            });
        };
        _isMaximized = await mainWindow.IsMaximizedAsync();
    }

    private async Task HandleOpenMenuAsync(MouseEventArgs e)
    {
        await _menu.OpenAsync(_menuAnchor);
    }

    private async Task HandleOpenProjectAsync(MouseEventArgs e)
    {
        if (await _projectService.OpenAsync())
        {
            BuildDataGrid(_projectService.Project.Varieties.First());
            StateHasChanged();
            await _domService.FocusElementAsync(_syllablePatternField.InputRef);
        }
    }

    private async Task HandleSyllablePatternInputAsync(ChangeEventArgs e)
    {
        try
        {
            _cts?.Cancel();
            _cts = new CancellationTokenSource();
            CancellationToken ct = _cts.Token;
            await Task.Delay(500, ct);
            if (!ct.IsCancellationRequested)
            {
                SyllablePattern = e.Value.ToString();
            }
        }
        catch (OperationCanceledException)
        {
        }
    }

    private void BuildDataGrid(Variety variety)
    {
        _rows = new List<PhraseRow>();
        if (variety.Words.Count == 0)
            return;
        var rows = new List<PhraseRow>();
        var columns = new List<DataGridColumn>();
        if (string.IsNullOrEmpty(_syllablePattern))
        {
            foreach (Word word in variety.Words)
            {
                rows.Add(new PhraseRow
                {
                    Phrase = word.StrRep,
                    Gloss = word.Meaning.Gloss,
                    AudioSegment = CreateAudioSegment(word.Audio),
                    Participants = word.Participants
                });
            }
        }
        else
        {
            Dictionary<Word, Range<int>> results = _projectService.SearchWords(variety, _syllablePattern);
            if (results.Count == 0)
                return;
            Alignment<Word, ShapeNode> alignment = _projectService.Align(results.Keys);
            var typeCounts = new Dictionary<string, Dictionary<FeatureSymbol, int>>();
            for (int i = 0; i < alignment.SequenceCount; i++)
            {
                Word word = alignment.Sequences[i];
                Range<int> range = results[word];

                var segments = new Dictionary<string, string>();
                for (int j = 0; j < alignment.ColumnCount; j++)
                {
                    var key = $"col_{j}";
                    AlignmentCell<ShapeNode> cell = alignment[i, j];
                    string strRep;
                    if (cell.Count == 0)
                    {
                        strRep = "-";
                    }
                    else
                    {
                        strRep = cell.OriginalStrRep();
                        var counts = typeCounts.GetOrCreate(key, () => new Dictionary<FeatureSymbol, int>());
                        counts.UpdateValue(cell.First.Type(), () => 0, c => c + 1);
                        if (range.Contains(word.Shape.IndexOf(cell.First)))
                            strRep = $"<b>{strRep}</b>";
                    }
                    segments[key] = strRep;
                }
                rows.Add(new PhraseRow
                {
                    Phrase = word.StrRep,
                    LeftContext = word.Prefix?.OriginalStrRep() ?? "",
                    RightContext = word.Suffix?.OriginalStrRep() ?? "",
                    Gloss = word.Meaning.Gloss,
                    Segments = segments,
                    AudioSegment = CreateAudioSegment(word.Audio),
                    Participants = word.Participants
                });
            }

            var segmentColumns = new List<DataGridValueColumn>();
            segmentColumns.Add(new DataGridValueColumn
            {
                Title = "Left",
                Field = nameof(PhraseRow.LeftContext),
                Align = ColumnAlign.Right,
                HeaderFilter = Editor.Input,
                HeaderFilterPlaceholder = " "
            });
            for (int j = 0; j < alignment.ColumnCount; j++)
            {
                var key = $"col_{j}";
                string title = "?";
                if (typeCounts.TryGetValue(key, out Dictionary<FeatureSymbol, int> counts) && counts.Count > 0)
                {
                    FeatureSymbol type = counts.MaxBy(kvp => kvp.Value).Key;
                    if (type == CogFeatureSystem.ConsonantType)
                        title = "C";
                    else
                        title = "V";
                }
                segmentColumns.Add(new DataGridValueColumn
                {
                    Title = title,
                    Field = $"{nameof(PhraseRow.Segments)}.{key}",
                    MinWidth = 50,
                    CssClass = "dense-col",
                    Align = ColumnAlign.Center,
                    HeaderFilter = Editor.Select,
                    HeaderFilterParams = new SelectParams { Values = true },
                    HeaderFilterPlaceholder = " ",
                    Formatter = Formatter.Html
                });
            }
            segmentColumns.Add(new DataGridValueColumn
            {
                Title = "Right",
                Field = nameof(PhraseRow.RightContext),
                Align = ColumnAlign.Left,
                HeaderFilter = Editor.Input,
                HeaderFilterPlaceholder = " "
            });
            columns.Add(new DataGridColumnGroup
            {
                Title = "Alignment",
                Columns = segmentColumns
            });
        }

        columns.Add(new DataGridValueColumn
        {
            Title = "Phrase/Word",
            Field = nameof(PhraseRow.Phrase),
            HeaderFilter = Editor.Input,
            HeaderFilterPlaceholder = " "
        });
        columns.Add(new DataGridValueColumn
        {
            Field = nameof(PhraseRow.AudioSegment),
            HeaderSort = false,
            Formatter = Formatter.Audio
        });
        columns.Add(new DataGridValueColumn
        {
            Title = "Gloss",
            Field = nameof(PhraseRow.Gloss),
            HeaderFilter = Editor.Input,
            HeaderFilterPlaceholder = " "
        });
        columns.Add(new DataGridValueColumn
        {
            Title = "People",
            Field = nameof(PhraseRow.Participants),
            HeaderFilter = Editor.Input,
            HeaderFilterPlaceholder = " "
        });

        _columns = columns;
        _rows = rows;
    }

    private void HandleMinimize()
    {
        BrowserWindow window = Electron.WindowManager.BrowserWindows.First();
        window.Minimize();
    }

    private void HandleMaximize()
    {
        BrowserWindow window = Electron.WindowManager.BrowserWindows.First();
        window.Maximize();
    }

    private void HandleUnmaximize()
    {
        BrowserWindow window = Electron.WindowManager.BrowserWindows.First();
        window.Unmaximize();
    }

    private void HandleClose()
    {
        BrowserWindow window = Electron.WindowManager.BrowserWindows.First();
        window.Close();
    }

    private static AudioSegment CreateAudioSegment(Audio audio)
    {
        string fileUrl = FilePathToFileUrl(audio.FileName);
        float start = audio.StartOffset / 1000f;
        float end = audio.EndOffset / 1000f;
        return new AudioSegment
        {
            Url = fileUrl,
            StartOffset = start,
            EndOffset = end
        };
    }

    private static string FilePathToFileUrl(string filePath)
    {
        var uri = new StringBuilder();
        foreach (char v in filePath)
        {
            if ((v >= 'a' && v <= 'z') || (v >= 'A' && v <= 'Z') || (v >= '0' && v <= '9') || v == '+' || v == '/'
                    || v == ':' || v == '.' || v == '-' || v == '_' || v == '~' || v > '\xFF')
            {
                uri.Append(v);
            }
            else if (v == Path.DirectorySeparatorChar || v == Path.AltDirectorySeparatorChar)
            {
                uri.Append('/');
            }
            else
            {
                uri.Append(String.Format("%{0:X2}", (int)v));
            }
        }
        if (uri.Length >= 2 && uri[0] == '/' && uri[1] == '/') // UNC path
            uri.Insert(0, "file:");
        else
            uri.Insert(0, "file:///");
        return uri.ToString();
    }
}
