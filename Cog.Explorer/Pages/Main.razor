@page "/"

@using SIL.Extensions
@using SIL.Machine.Annotations
@using SIL.Machine.FeatureModel
@using SIL.Machine.SequenceAlignment

@inject ProjectService _projectService

<header id="titlebar" class="@(_isMaximized ? "maximized" : "")">
    <div class="titlebar-buttons">
        <MatIconButton Icon="folder_open" OnClick="@OpenProjectAsync"></MatIconButton>
    </div>
    <div class="titlebar-drag-region"></div>
    <div id="window-controls">
        <div class="button" id="min-button" @onclick="HandleMinimize">
            <span>&#xE921;</span>
        </div>
        <div class="button" id="max-button" @onclick="HandleMaximize">
            <span>&#xE922;</span>
        </div>
        <div class="button" id="restore-button" @onclick="HandleUnmaximize">
            <span>&#xE923;</span>
        </div>
        <div class="button" id="close-button" @onclick="HandleClose">
            <span>&#xE8BB;</span>
        </div>
    </div>
</header>
<div class="main-content">
    @if (!_projectService.IsLoaded)
    {
        <MatSubtitle1 Class="no-data-label">No project loaded.</MatSubtitle1>
    }
    else
    {
        <div>
            <MatTextField Label="Syllable Pattern" @bind-Value="@SyllablePattern" Dense="true"></MatTextField>
        </div>
        if (_rows.Count == 0)
        {
            <MatSubtitle1 Class="no-data-label">No matching phrases.</MatSubtitle1>
        }
        else
        {
            <DataGrid Columns="@_columns" Items="@_rows"></DataGrid>
        }
    }
</div>

@code {
    string _syllablePattern;
    List<DataGridColumn> _columns = new List<DataGridColumn>();
    List<PhraseRow> _rows = new List<PhraseRow>();
    bool _isMaximized = false;

    private string SyllablePattern
    {
        get => _syllablePattern;
        set
        {
            if (_syllablePattern != value)
            {
                _syllablePattern = value;
                StateHasChanged();
                BuildDataGrid(_projectService.Project.Varieties.First());
            }
        }
    }

    protected override async Task OnInitializedAsync()
    {
        BrowserWindow mainWindow = Electron.WindowManager.BrowserWindows.First();
        mainWindow.OnMaximize += async () =>
        {
            await InvokeAsync(() =>
            {
                _isMaximized = true;
                StateHasChanged();
            });
        };
        mainWindow.OnUnmaximize += async () =>
        {
            await InvokeAsync(() =>
            {
                _isMaximized = false;
                StateHasChanged();
            });
        };
        _isMaximized = await mainWindow.IsMaximizedAsync();
    }

    private async Task OpenProjectAsync(MouseEventArgs e)
    {
        await _projectService.OpenAsync();
        BuildDataGrid(_projectService.Project.Varieties.First());
    }

    private void BuildDataGrid(Variety variety)
    {
        _rows = new List<PhraseRow>();
        if (string.IsNullOrEmpty(_syllablePattern))
            return;

        IReadOnlyList<Word> words = _projectService.FocusWords(variety, _syllablePattern);

        IWordAligner aligner = _projectService.Project.WordAligners[ComponentIdentifiers.PrimaryWordAligner];
        IWordAlignerResult result = aligner.Compute(words);
        Alignment<Word, ShapeNode> alignment = result.GetAlignments().First();

        var rows = new List<PhraseRow>();
        var typeCounts = new Dictionary<string, Dictionary<FeatureSymbol, int>>();
        for (int i = 0; i < alignment.SequenceCount; i++)
        {
            Word word = alignment.Sequences[i];

            var segments = new Dictionary<string, string>();
            for (int j = 0; j < alignment.ColumnCount; j++)
            {
                var key = $"col_{j}";
                AlignmentCell<ShapeNode> cell = alignment[i, j];
                string strRep;
                if (cell.Count == 0)
                {
                    strRep = "-";
                }
                else
                {
                    strRep = cell.OriginalStrRep();
                    var counts = typeCounts.GetOrCreate(key, () => new Dictionary<FeatureSymbol, int>());
                    counts.UpdateValue(cell.First.Type(), () => 0, c => c + 1);
                }
                segments[key] = strRep;
            }
            rows.Add(new PhraseRow
            {
                Phrase = word.StrRep,
                LeftContext = word.Prefix?.OriginalStrRep() ?? "",
                RightContext = word.Suffix?.OriginalStrRep() ?? "",
                Gloss = word.Meaning.Gloss,
                Segments = segments
            });
        }

        var segmentColumns = new List<DataGridValueColumn>();
        for (int j = 0; j < alignment.ColumnCount; j++)
        {
            var key = $"col_{j}";
            string title = "?";
            if (typeCounts.TryGetValue(key, out Dictionary<FeatureSymbol, int> counts) && counts.Count > 0)
            {
                FeatureSymbol type = counts.MaxBy(kvp => kvp.Value).Key;
                if (type == CogFeatureSystem.ConsonantType)
                    title = "C";
                else
                    title = "V";
            }
            segmentColumns.Add(new DataGridValueColumn(title)
            {
                Field = $"{nameof(PhraseRow.Segments)}.{key}",
                MinWidth = 50,
                CssClass = "dense-col",
                Align = ColumnAlign.Center,
                HeaderFilter = Editor.Select,
                HeaderFilterParams = new SelectParams { Values = true },
                HeaderFilterPlaceholder = " "
            });
        }

        var columns = new List<DataGridColumn>
        {
            new DataGridValueColumn("Phrase/Word")
            {
                Field = nameof(PhraseRow.Phrase),
                HeaderFilter = Editor.Input,
                HeaderFilterPlaceholder = " "
            },
            new DataGridValueColumn("Left")
            {
                Field = nameof(PhraseRow.LeftContext),
                Align = ColumnAlign.Right,
                HeaderFilter = Editor.Input,
                HeaderFilterPlaceholder = " "
            },
            new DataGridColumnGroup("Segments") { Columns = segmentColumns },
            new DataGridValueColumn("Right")
            {
                Field = nameof(PhraseRow.RightContext),
                Align = ColumnAlign.Left,
                HeaderFilter = Editor.Input,
                HeaderFilterPlaceholder = " "
            },
            new DataGridValueColumn("Gloss")
            {
                Field = nameof(PhraseRow.Gloss),
                HeaderFilter = Editor.Input,
                HeaderFilterPlaceholder = " "
            }
        };

        _columns = columns;
        _rows = rows;
    }

    private void HandleMinimize()
    {
        BrowserWindow window = Electron.WindowManager.BrowserWindows.First();
        window.Minimize();
    }

    private void HandleMaximize()
    {
        BrowserWindow window = Electron.WindowManager.BrowserWindows.First();
        window.Maximize();
    }

    private void HandleUnmaximize()
    {
        BrowserWindow window = Electron.WindowManager.BrowserWindows.First();
        window.Unmaximize();
    }

    private void HandleClose()
    {
        BrowserWindow window = Electron.WindowManager.BrowserWindows.First();
        window.Close();
    }
}
