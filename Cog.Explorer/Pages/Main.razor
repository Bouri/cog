@page "/"

@using System.Threading
@using SIL.Extensions
@using SIL.Machine.Annotations
@using SIL.Machine.FeatureModel
@using SIL.Machine.SequenceAlignment

@inject ProjectService _projectService

<header id="titlebar" class="@(_isMaximized ? "maximized" : "")">
    <div class="titlebar-buttons">
        <MatIconButton Icon="folder_open" OnClick="@HandleOpenProjectAsync"></MatIconButton>
    </div>
    <div class="titlebar-drag-region"></div>
    <div id="window-controls">
        <div class="button" id="min-button" @onclick="HandleMinimize">
            <span>&#xE921;</span>
        </div>
        <div class="button" id="max-button" @onclick="HandleMaximize">
            <span>&#xE922;</span>
        </div>
        <div class="button" id="restore-button" @onclick="HandleUnmaximize">
            <span>&#xE923;</span>
        </div>
        <div class="button" id="close-button" @onclick="HandleClose">
            <span>&#xE8BB;</span>
        </div>
    </div>
</header>
<div class="main-content">
    @if (!_projectService.IsLoaded)
    {
        <MatSubtitle1 Class="no-data-label">No project loaded.</MatSubtitle1>
    }
    else
    {
        <div class="syllable-pattern-field">
            <MatTextField Label="Syllable Pattern"
                          OnInput="@HandleSyllablePatternInputAsync">
            </MatTextField>
        </div>
        <div class="data-grid-container">
            <DataGrid Columns="@_columns" Items="@_rows"></DataGrid>
        </div>
    }
</div>

@code {
    private string _syllablePattern;
    private List<DataGridColumn> _columns = new List<DataGridColumn>();
    private List<PhraseRow> _rows = new List<PhraseRow>();
    private bool _isMaximized = false;
    private CancellationTokenSource _cts;

    private string SyllablePattern
    {
        get => _syllablePattern;
        set
        {
            if (_syllablePattern != value)
            {
                _syllablePattern = value;
                StateHasChanged();
                BuildDataGrid(_projectService.Project.Varieties.First());
            }
        }
    }

    protected override async Task OnInitializedAsync()
    {
        BrowserWindow mainWindow = Electron.WindowManager.BrowserWindows.First();
        mainWindow.OnMaximize += async () =>
        {
            await InvokeAsync(() =>
            {
                _isMaximized = true;
                StateHasChanged();
            });
        };
        mainWindow.OnUnmaximize += async () =>
        {
            await InvokeAsync(() =>
            {
                _isMaximized = false;
                StateHasChanged();
            });
        };
        _isMaximized = await mainWindow.IsMaximizedAsync();
    }

    private async Task HandleOpenProjectAsync(MouseEventArgs e)
    {
        await _projectService.OpenAsync();
        BuildDataGrid(_projectService.Project.Varieties.First());
    }

    private async Task HandleSyllablePatternInputAsync(ChangeEventArgs e)
    {
        try
        {
            _cts?.Cancel();
            _cts = new CancellationTokenSource();
            CancellationToken ct = _cts.Token;
            await Task.Delay(500, ct);
            if (!ct.IsCancellationRequested)
            {
                SyllablePattern = e.Value.ToString();
            }
        } catch (OperationCanceledException)
        {
        }
    }

    private void HandleAlign(MouseEventArgs e)
    {
        BuildDataGrid(_projectService.Project.Varieties.First());
    }

    private void BuildDataGrid(Variety variety)
    {
        _rows = new List<PhraseRow>();
        Dictionary<Word, Range<int>> results;
        if (string.IsNullOrEmpty(_syllablePattern))
            results = variety.Words.ToDictionary(w => w, w => Range<int>.Null);
        else
            results = _projectService.SearchWords(variety, _syllablePattern);
        if (results.Count == 0)
            return;

        Alignment<Word, ShapeNode> alignment = _projectService.Align(results.Keys);
        var rows = new List<PhraseRow>();
        var typeCounts = new Dictionary<string, Dictionary<FeatureSymbol, int>>();
        for (int i = 0; i < alignment.SequenceCount; i++)
        {
            Word word = alignment.Sequences[i];
            Range<int> range = results[word];

            var segments = new Dictionary<string, string>();
            for (int j = 0; j < alignment.ColumnCount; j++)
            {
                var key = $"col_{j}";
                AlignmentCell<ShapeNode> cell = alignment[i, j];
                string strRep;
                if (cell.Count == 0)
                {
                    strRep = "-";
                }
                else
                {
                    strRep = cell.OriginalStrRep();
                    var counts = typeCounts.GetOrCreate(key, () => new Dictionary<FeatureSymbol, int>());
                    counts.UpdateValue(cell.First.Type(), () => 0, c => c + 1);
                    if (range.Contains(word.Shape.IndexOf(cell.First)))
                        strRep = $"<b>{strRep}</b>";
                }
                segments[key] = strRep;
            }
            rows.Add(new PhraseRow
            {
                Phrase = word.StrRep,
                LeftContext = word.Prefix?.OriginalStrRep() ?? "",
                RightContext = word.Suffix?.OriginalStrRep() ?? "",
                Gloss = word.Meaning.Gloss,
                Segments = segments
            });
        }

        var segmentColumns = new List<DataGridValueColumn>();
        segmentColumns.Add(new DataGridValueColumn("Left")
        {
            Field = nameof(PhraseRow.LeftContext),
            Align = ColumnAlign.Right,
            HeaderFilter = Editor.Input,
            HeaderFilterPlaceholder = " "
        });
        for (int j = 0; j < alignment.ColumnCount; j++)
        {
            var key = $"col_{j}";
            string title = "?";
            if (typeCounts.TryGetValue(key, out Dictionary<FeatureSymbol, int> counts) && counts.Count > 0)
            {
                FeatureSymbol type = counts.MaxBy(kvp => kvp.Value).Key;
                if (type == CogFeatureSystem.ConsonantType)
                    title = "C";
                else
                    title = "V";
            }
            segmentColumns.Add(new DataGridValueColumn(title)
            {
                Field = $"{nameof(PhraseRow.Segments)}.{key}",
                MinWidth = 50,
                CssClass = "dense-col",
                Align = ColumnAlign.Center,
                HeaderFilter = Editor.Select,
                HeaderFilterParams = new SelectParams { Values = true },
                HeaderFilterPlaceholder = " ",
                Formatter = Formatter.Html
            });
        }
        segmentColumns.Add(new DataGridValueColumn("Right")
        {
            Field = nameof(PhraseRow.RightContext),
            Align = ColumnAlign.Left,
            HeaderFilter = Editor.Input,
            HeaderFilterPlaceholder = " "
        });

        var columns = new List<DataGridColumn>();
        if (!string.IsNullOrEmpty(_syllablePattern))
            columns.Add(new DataGridColumnGroup("Alignment") { Columns = segmentColumns });
        columns.Add(new DataGridValueColumn("Phrase/Word")
        {
            Field = nameof(PhraseRow.Phrase),
            HeaderFilter = Editor.Input,
            HeaderFilterPlaceholder = " "
        });
        columns.Add(new DataGridValueColumn("Gloss")
        {
            Field = nameof(PhraseRow.Gloss),
            HeaderFilter = Editor.Input,
            HeaderFilterPlaceholder = " "
        });

        _columns = columns;
        _rows = rows;
    }

    private void HandleMinimize()
    {
        BrowserWindow window = Electron.WindowManager.BrowserWindows.First();
        window.Minimize();
    }

    private void HandleMaximize()
    {
        BrowserWindow window = Electron.WindowManager.BrowserWindows.First();
        window.Maximize();
    }

    private void HandleUnmaximize()
    {
        BrowserWindow window = Electron.WindowManager.BrowserWindows.First();
        window.Unmaximize();
    }

    private void HandleClose()
    {
        BrowserWindow window = Electron.WindowManager.BrowserWindows.First();
        window.Close();
    }
}
